## Question
>Let's start off simple, can you overflow the right buffer in this [program](//2018shell.picoctf.com/static/b3e4e30f1c9d3fdd1ce245c849187c36/vuln) to get the flag? You can also find it in /problems/buffer-overflow-0_1_316c391426b9319fbdfb523ee15b37db on the shell server. [Source](//2018shell.picoctf.com/static/b3e4e30f1c9d3fdd1ce245c849187c36/vuln.c).

### Hint
>How can you trigger the flag to print?
>If you try to do the math by hand, maybe try and add a few more characters. Sometimes there are things you aren't expecting.

## Solution
To kick it off, after navigating to the problem's location in our shell we can `ls` to see 3 files:
```bash
flag.txt  vuln  vuln.c
```
Trying to be a "smartass" gets us nowhere as we don't have premission to access `flag.txt`:
```bash
cat: flag.txt: Permission denied
```
So lets inspect the code in `vuln.c`:
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <signal.h>

#define FLAGSIZE_MAX 64

char flag[FLAGSIZE_MAX];

void sigsegv_handler(int sig) {
  fprintf(stderr, "%s\n", flag);
  fflush(stderr);
  exit(1);
}

void vuln(char *input){
  char buf[16];
  strcpy(buf, input);
}

int main(int argc, char **argv){

  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are runni
ng this on the shell server.\n");                                                                   
    exit(0);                                                                                        
  }                                                                                                 
  fgets(flag,FLAGSIZE_MAX,f);                                                                       
  signal(SIGSEGV, sigsegv_handler);                                                                 

  gid_t gid = getegid();                                                                            
  setresgid(gid, gid, gid);                                                                         

  if (argc > 1) {                                                                                   
    vuln(argv[1]);                                                                                  
    printf("Thanks! Received: %s", argv[1]);                                                        
  }                                                                                                 
  else                                                                                              
    printf("This program takes 1 argument.\n");                                                     
  return 0;                                                                                         
}        
```
```c
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. Problem is Misconfigured, please contact an Admin if you are runni
ng this on the shell server.\n");                                                                   
    exit(0);                                                                                        
  }                                                                                                 
  fgets(flag,FLAGSIZE_MAX,f);
```
The program starts by opening `flag.txt` and storing the flag in a variable names `flag`.
```c
signal(SIGSEGV, sigsegv_handler);
```
Then it uses the [signal fuction](https://www.tutorialspoint.com/c_standard_library/c_function_signal.htm) to handle invalid access to storage using the defined function `sigsegv_handler`, lets take a look at it:
```c
void sigsegv_handler(int sig) {
  fprintf(stderr, "%s\n", flag);
  fflush(stderr);
  exit(1);
}
```
This function is our key to the flag as it prints an error containing the `flag` variable.
```c
  if (argc > 1) {                                                                                   
    vuln(argv[1]);                                                                                  
    printf("Thanks! Received: %s", argv[1]);                                                        
  }
```
While given an argument the program passes it to the predefined `vuln` function:
```c
void vuln(char *input){
  char buf[16];
  strcpy(buf, input);
}
```
This function copies our argument string over to `buf` without checking for boundaries - causing `sigsegv_handler` to be called when an argument longer than the size of `buf` is handed over to the program:
```bash
pico-2018-shell:/problems/buffer-overflow-0_1_316c391426b9319fbdfb523ee15b37db$ ./vuln aasdkosdkoskdoskdos
kadokdksodksodk
```

### Flag
`picoCTF{ov3rfl0ws_ar3nt_that_bad_3598a894}`
